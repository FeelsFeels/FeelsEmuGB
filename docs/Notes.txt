The bible
https://gbdev.io/pandocs/

Opcode table
https://gbdev.io/gb-opcodes/optables/
https://izik1.github.io/gbops/

CPU Instructions reference
https://rgbds.gbdev.io/docs/v1.0.0/gbz80.7

The Ultimate GameBoy Talk
https://www.youtube.com/watch?v=HyzD8pNlpwI

Tester ROMs
https://github.com/retrio/gb-test-roms



==============================
====== Design Decisions ======
==============================
My emulator is built with the goal of helping myself (and others!) better understand the Game Boy.
I want lots of debug info. I want the ability to inspect the values. I want the user to KNOW what is happening under the hood.
I want to implement the scrolling visualizer just like the Ultimate Game Boy Talk displayed.
I want a sound visualizer as well.




Components:
Game Boy
CPU
Bus/MMU
PPU
Cartridge


====================
====== NOTES =======
====================
On the memory map:
The GB has a 16-bit address space, 0x0000 - 0xFFFF

0000	3FFF	16 KiB: Cartridge. Fixed Bank
4000	7FFF	16 KiB: Cartridge. Switchable ROM Bank. We access "extra memory" in the cartridge (PokÃ©mon red is 512KB!) in this address range via the Memory Bank Controller (MBC).
8000	9FFF	 8 KiB: Video RAM. Tile Data, Tile Maps. Important for the PPU.
A000	BFFF	 8 KiB: External RAM. This lives on the cartridge. I think this is where the save files can live.
C000	DFFF	 8 KiB: Work RAM.
E000	FDFF this section is broken. It's a mirror of C000-DDFF. Just don't use this, or redirect to the work RAM.
FE00	FE9F	     : Object Attribute Memory (OAM). Holds up to 40 sprites.
FEA0	FEFF	Not Usable
FF00	FF7F	     : I/O Registers
FF80	FFFE	     : High RAM (HRAM). 127 bytes of RAM that can be accessed faster (similar to CPU cache)
FFFF	FFFF	Interrupt Enable register (IE)


On the Memory Bank Controller (MBC):
https://retrocomputing.stackexchange.com/questions/11732/how-does-the-gameboys-memory-bank-switching-work


On "Registers":
The CPU has registers, but the docs also mention the cartridge having registers.
The registers of the cartridge are better thought of as control switches than the standard definition of registers on the CPU.

On CPU Registers:
7 General 8-bit registers: A B C D E H L
Some registers can be combined to make 16 bit registers: AF, BC, DE, HL
A refers to Hi bits of AF. F is the flags register.
A register is special. It is the accumulator. The only register that can be used for certain load instructions.
HL register is usually the only register that can be used for addresses when accessing memory.

Two more registers, SP & PC, for stack and program pointer.


On Opcodes / execution:
Similar to what an OS module would have taught.
All n and a and e parameters come from the bytes immediately following the opcode in memory.
Memory:
[PC]     -> 0x3E        (opcode for LD A, n8)
[PC+1]   -> 0x42        (the n8 value = 66)
[PC+2]   -> next opcode


On CPU Flags:
Documentation for the Half-carry flag for 16 bit additions
http://www.z80.info/z80code.htm
                        16 bit ADC group

The 16 bit ADC instructions use the HL register instead of the  A
register. The flags are affected as follows

C or carry flag          1 if answer >65536 else 0
Z or zero flag           1 if result = 0 else 0
P flag                   1 if TC <-32768 or >32767 else 0
S or sign flag           1 if 32767 < n < 65536 else 0
N flag                   0
H or half carry flag     1 if carry from bit 11 else 0

One more edge case:
Opcode 0xE8, ADD SP,e8
H-flag set when bit 3 overflows to bit 4
https://stackoverflow.com/questions/57958631/game-boy-half-carry-flag-and-16-bit-instructions-especially-opcode-0xe8


On the Boot ROM:
Exists in 0000-00FF. Recall that the entry point of the cartridge is 0100-0103.
This small program, the boot ROM, is burned inside the CPU, and is mapped over (overlapped) the cartridge ROM on startup.
This means that the boot ROM supercedes the cartridge code inside 0000-00FF until it finishes.
After finishing, the boot ROM hands off control to the cartridge at 0x0100.


On the Timer:
https://github.com/Ashiepaws/GBEDG/blob/master/timers/index.md


On Graphics:
https://www.huderlem.com/demos/gameboy2bpp.html
Tile data is stored in VRAM, 0x8000-0x97FF
Each tile is 16 bytes. Thus 384 tiles. Stored in three "blocks" of 128 tiles each
Each tile is 8x8 pixels.
Each line is represented by 2 bytes. (8 lines)
Each pixel has 2 bits of color depth, 4 colors (grey shades)
Example of a tile:
FF 00 7E FF 85 81 89 83 93 85 A5 8B C9 97 7E FF
0xFF 0x00 represents the 1st row, 0x7E 0xFF represents the second, and so on.
Each pixel can have 4 colors (or more accurately said to be shades of grey) - 00, 01, 10, 11.
You get these colors by combining the bits of the high byte and low byte of the tile info.
For example, the second line: 7E (low byte) FF (high byte)
1111 1111
0111 1110
for the first pixel, we combine the high and low bytes to get a pixel color of 10 (color 3)
for the second pixel, 11.


Object, an entry in object attribute memory, composed of 1 or 2 tiles. Can be moved independently of the background.

Timing for graphics:
GB resolution: 160 x 144
Dots are same as cycles, one 4.194 Mhz time unit.
A frame consists of 154 scanlines (rows).
The gameboy's screen height is 144 pixels, and the PPU also defines a 10 extra scanline duration as it's V-blank (144 + 10) = 154 scanlines
One scanline is drawn in 456 dots, so total times taken for one frame is 456 x 154 = 70244 dots.
This 456 value is computed as such:
Each scanline is drawn in 3 phases - OAM retrival (always 80 dots), Drawing(172-289 dots), H-Blank(87-204 dots).
The H blank actual duration seems to be 87, but will compensate and take extra time depending on how fast the drawing stage took, leading to a consistent 456 dot timing for one scanline.


On Interrupts:
3 main parts that control the interrupt system.
IF register 0xFF0F - The state of the interrupts. "Do I need to handle any interrupts?"
IE register 0xFFFF - Interrupt table. Enables/Disables whether each interrupt can be called.
IME flag, internal to cpu - Enables/Disables all interrupts globally.

