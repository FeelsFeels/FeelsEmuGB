The bible
https://gbdev.io/pandocs/

Opcode table
https://gbdev.io/gb-opcodes/optables/
https://izik1.github.io/gbops/

CPU Instructions reference
https://rgbds.gbdev.io/docs/v1.0.0/gbz80.7

The Ultimate GameBoy Talk
https://www.youtube.com/watch?v=HyzD8pNlpwI

Tester ROMs
https://github.com/retrio/gb-test-roms



==============================
====== Design Decisions ======
==============================
My emulator is built with the goal of helping myself (and others!) better understand the Game Boy.
I want lots of debug info. I want the ability to inspect the values. I want the user to KNOW what is happening under the hood.
I want to implement the scrolling visualizer just like the Ultimate Game Boy Talk displayed.
I want a sound visualizer as well.


Possible Liabilities:
Currently, saving the game's ram only happens in the destructor of the cartridge class. Therefore, if the emulator crashes, the save file is not updated.

Components:
Game Boy
CPU
Bus/MMU
PPU
Cartridge


====================
====== NOTES =======
====================
On the memory map:
The GB has a 16-bit address space, 0x0000 - 0xFFFF

0000	3FFF	16 KiB: Cartridge. Fixed Bank
4000	7FFF	16 KiB: Cartridge. Switchable ROM Bank. We access "extra memory" in the cartridge (PokÃ©mon red is 512KB!) in this address range via the Memory Bank Controller (MBC).
8000	9FFF	 8 KiB: Video RAM. Tile Data, Tile Maps. Important for the PPU.
A000	BFFF	 8 KiB: External RAM. This lives on the cartridge. I think this is where the save files can live.
C000	DFFF	 8 KiB: Work RAM.
E000	FDFF this section is broken. It's a mirror of C000-DDFF. Just don't use this, or redirect to the work RAM.
FE00	FE9F	     : Object Attribute Memory (OAM). Holds up to 40 sprites.
FEA0	FEFF	Not Usable
FF00	FF7F	     : I/O Registers
FF80	FFFE	     : High RAM (HRAM). 127 bytes of RAM that can be accessed faster (similar to CPU cache)
FFFF	FFFF	Interrupt Enable register (IE)


On the Memory Bank Controller (MBC):
https://retrocomputing.stackexchange.com/questions/11732/how-does-the-gameboys-memory-bank-switching-work

The general concept is you write to ranges to switch which memory bank you are reading from. 
Since the gameboy can only read from a 16-bit address space, this allows you to read from more memory than the address space allows.

On MBC1:
0x0000-0x3FFF - Read only, cannot switch nor modify.
0x4000-0x7FFF - Read only. Contains whatever memory bank is currently being selected.
0xA000-0xBFFF - Read/Write. This is where the RAM bank lives, if present. Can have multiple banks as well.

Writes to control:
0x0000-0x1FFF - Writing to this range enables/disables RAM. Write the value 0x0A to anywhere in this range to enable. Any other value disables it.
0x2000-0x3FFF - Writing to this range switches the ROM Bank. Only the bottom 5 bits are taken into account.
                Writing 0xE1 (111 00001) will select rom bank 01. IMPORTANT CONCEPT: If set to 0, it behaves as if it was set to bank 01.
                If the number of rom banks need only, say, 4 bits to represent, the 5th bit is masked, which ignores it for bank selection.
                  Even so, 0b10000 is considered different from 0b00000, so you can map bank 0 on smaller Cartridges this way.
                
0x4000-0x5FFF - Larger carts needing >5bits bank numbers, there is a second banking register located here, which supplies 2 additional bits for the bank number.
                Final computation: Selected ROM Bank = (Secondary Bank << 5) + Primary ROM Bank
                Weird behaviour: these two extra bits are not taken into account for the bank 00 -> 01 translation as described above.
                Thus, accessing bank 0x20, 0x40, and 0x60 selects bank 0x21, 0x41, and 0x61 instead.
                This 2 bit register can also be used to select the RAM Bank, depending on the ROM/RAM selection mode(below).

0x6000-0x7FFF - 1 bit register representing Banking Mode select. Controls the behaviour of the Secondary 2 bit bank selection register.
                0: Simple(default). 0x0000-0x3FFF for ROM and 0xA000-0xBFFF for RAM is locked to bank 0 of ROM and SRAM.
                1: Advanced. 0x0000-0x3FFF and 0xA000-0xBFFF can now be switched via the second banking register.

============================================

On "Registers":
The CPU has registers, but the docs also mention the cartridge having registers.
The registers of the cartridge are better thought of as control switches than the standard definition of registers on the CPU.

On CPU Registers:
7 General 8-bit registers: A B C D E H L
Some registers can be combined to make 16 bit registers: AF, BC, DE, HL
A refers to Hi bits of AF. F is the flags register.
A register is special. It is the accumulator. The only register that can be used for certain load instructions.
HL register is usually the only register that can be used for addresses when accessing memory.

Two more registers, SP & PC, for stack and program pointer.

============================================

On Opcodes / execution:
Similar to what an OS module would have taught.
All n and a and e parameters come from the bytes immediately following the opcode in memory.
Memory:
[PC]     -> 0x3E        (opcode for LD A, n8)
[PC+1]   -> 0x42        (the n8 value = 66)
[PC+2]   -> next opcode

HALT bug: honestly i still really don't understand. Will update if i ever fully internalize this.
============================================

On CPU Flags:
Documentation for the Half-carry flag for 16 bit additions
http://www.z80.info/z80code.htm
                        16 bit ADC group

The 16 bit ADC instructions use the HL register instead of the  A
register. The flags are affected as follows

C or carry flag          1 if answer >65536 else 0
Z or zero flag           1 if result = 0 else 0
P flag                   1 if TC <-32768 or >32767 else 0
S or sign flag           1 if 32767 < n < 65536 else 0
N flag                   0
H or half carry flag     1 if carry from bit 11 else 0

One more edge case:
Opcode 0xE8, ADD SP,e8
H-flag set when bit 3 overflows to bit 4
https://stackoverflow.com/questions/57958631/game-boy-half-carry-flag-and-16-bit-instructions-especially-opcode-0xe8

============================================

On the Boot ROM:
Exists in 0000-00FF. Recall that the entry point of the cartridge is 0100-0103.
This small program, the boot ROM, is burned inside the CPU, and is mapped over (overlapped) the cartridge ROM on startup.
This means that the boot ROM supercedes the cartridge code inside 0000-00FF until it finishes.
After finishing, the boot ROM hands off control to the cartridge at 0x0100.

============================================

On the Timer:
https://github.com/Ashiepaws/GBEDG/blob/master/timers/index.md
Timer registers:
*UINT16_T* div { 0 };	// Divider. Always increments at a rate of rate of 16384Hz. This is your "true" counter of how many cycles have passed
uint8_t tima{ 0 };	    // Timer counter. Increments at TAC frequency. 
uint8_t tma { 0 };	    // Modulo. tima resets to tma when tima overflows.
uint8_t tac { 0 };      // Controller. Controls timer enabled, clock speed, etc

TIMA, on overflow, triggers a hardware TIMER interrupt.
TIMA ticks on falling edge, that is, when the target bit on DIV(target controlled in tac), goes from 1 -> 0, tima increments.
Timer bug - this falling edge detector actually depends on BOTH timerEnabled and the target bit, so writing to tac at sometimes would trigger tima++.

============================================

On Input:
    5       4
    A      Right   0
    B      Left    1
  Start    Up      2
  Select   Down    3

The gameboy writes to 0xFF00, the input register, to select if it wants to read the left or right column of inputs.
Game dev's process if they want to read, say, START
Write 0b 1101 1111 to 0xFF00
Read from 0xFF00. If only start was pressed, 0xFF00 would contain 0b 1101 1011
For gameboy input, if bit == 0, button is down. Same goes for the "Selector"

============================================

On Graphics:
VRAM Structure:
Tile Data - stored in 0x8000-0x97FF, in two "blocks" or "addressing modes".
  0x8000-0x8FFF / 0x8800-0x97FF
Tile Maps - stored in 0x9800-0x9FFF. Two blocks of 32x32 grids(0x9800-0x9BFF and 0x9C00-0x9FFF). This is "Which tiles to display where"

https://www.huderlem.com/demos/gameboy2bpp.html
Each tile is 16 bytes. Thus 384 tiles. Stored in three "blocks" of 128 tiles each
Each tile is 8x8 pixels.
Each line is represented by 2 bytes. (8 lines)
Each pixel has 2 bits of color depth, 4 colors (grey shades)
Example of a tile:
FF 00 7E FF 85 81 89 83 93 85 A5 8B C9 97 7E FF
0xFF 0x00 represents the 1st row, 0x7E 0xFF represents the second, and so on.
Each pixel can have 4 colors (or more accurately said to be shades of grey) - 00, 01, 10, 11.
You get these colors by combining the bits of the high byte and low byte of the tile info.
For example, the second line: 7E (low byte) FF (high byte)
1111 1111
0111 1110
for the first pixel, we combine the high and low bytes to get a pixel color of 10 (color 3)
for the second pixel, 11. These two bits are what is called "color index", for the OAM priority later.

Graphics related registers
uint8_t lcdc;  // 0xFF40 LCD control https://gbdev.io/pandocs/LCDC.html#ff40--lcdc-lcd-control
uint8_t stat;  // 0xFF41 LCD status
uint8_t scy;   // 0xFF42 Viewport Y position
uint8_t scx;   // 0xFF43 Viewport X position
uint8_t ly;    // 0xFF44 LCD Y coordinate
uint8_t lyc;   // 0xFF45 LY compare
uint8_t bgp;   // 0xFF47 BD palette data

uint8_t wy;   // 0xFF4A Window position Y
uint8_t wx;   // 0xFF4B Window position X


Background:
The Gameboy screen is only 160x144. but the background is a 256x256 map (32 tiles * 8 pixels = 256). 
Tiles only contain references to the tiles in VRAM.
But each tile in the map can only store values of 0-255, while VRAM can store 384 tiles.
There is an additional setting in lcdc, ""BG & Window tiles", bit 4, which controls which "half" you are referencing.
0 being 0x8800-0x97FF, and 1 being 0x8000-0x8FFF in vram. Note the overlap! 0x8800-0x8FFF is overlapped! A 128 tile overlap.

Background can also be scrolled via scy and scx registers. These two registers specify which part of the 256x256 background is visible.
If values are larger than 255, like in the case of when scx = 40, (40 + 159) = 199, they loop around the screen.

The tilemap the background uses is specified at bit 3 of LCDC. 0 uses the tilemap at 0x9800, otherwise the 0x9C00 one.
Window has the same tilemap choosing behaviour, at bit 6 of LCDC.
The bytes in the tilemap is just an index pointing to the tile data.

Window:
wy and wx specify the Window's top-left pixel, but wx is + 7. namely wx=7, wy=0 is top left.
Windows are frequently used for immovable ui, like healthbar at the bottom of kirby.


OAM (object attribute map/memory) - think of these as objects / sprites
Controlled through 0xFF40 bit 1 and 2. Bit 1 enables/disables. Bit 2 controls size: 0 = 8x8, 1 = 8 x 16.

An object, an entry in OAM, is composed of 1 or 2 tiles(8x8 or 8x16 pixels). Can be moved independently of the background.
Limitation of hardware allows only 10 objects per scanline (row). Objects out of the screen, within the 256x256 BG map still contributes to the limitation.

Each object has an OAM Entry consisting of 4 bytes - Y Pos, X Pos, Tile Index, and Attributes. Stored in 0xFE00-0xFE9F
Positions are (0,0) at the top left. Objects anchored/origin at top right.
Position Y - for BOTH 8x8 and 8x16 sprites, 0x10(16 in decimal) will have its top border touching the top edge of the screen.
Position X - for a 8x8 sprite the "anchor is on the right". Meaning 0x00 will have it's right border at the leftmost edge of the screen. 
             0x04 is half cut off, 0x08 has left border touching leftmost edge.
Tile Index - in 8x8 mode, specifies tile index in vram. this means that only tiles from 0x8000-0x8FFF can be selected.
             in 8x16 mode, byte1 is top tile, byte2, the one that follows right after, is the bottom tile of the sprite.
CGB Palette, Bank: cgb mode only. im not supporting yet
DMG Palette - 0 uses OBP0, 0xFF48, 1 uses OBP1, 0xFF49
Flip X - Self explanatory
Flip Y - Self explanatory
Priority - if 1, BG and Window color indices 1-3 are drawn over this sprite.



On Palettes:
Remember the fact that the gameboy has 4 colors (color indexes) - 00, 01, 10, 11, with the colors being White, Light gray, Dark grey, and Black respectively
Each pixel has a ColorID as well - 0, 1, 2, 3.
The palettes remap the ColorID to these 4 color indexes.
There are two types of palletes - Background palette data, and OBJ palette data. What both of them do is self explanatory. It's just bg vs obj.
But note that the color index 0 is ignored for OBJ since 0 is transparent for OBJs. There are also two OBJ palettes. One at 0xFF48 and one at 0xFF49.
Each object chooses which palette to use from it's OAM entry (see above, "DMG Palette").




Timing for graphics:
GB resolution: 160 x 144
Dots are same as cycles, one 4.194 Mhz time unit.
A frame consists of 154 scanlines (rows).
The gameboy's screen height is 144 pixels, and the PPU also defines a 10 extra scanline duration as it's V-blank (144 + 10) = 154 scanlines
One scanline is drawn in 456 dots, so total times taken for one frame is 456 x 154 = 70244 dots.
This 456 value is computed as such:
Each scanline is drawn in 3 phases - OAM retrival (always 80 dots), Drawing(172-289 dots), H-Blank(87-204 dots).
The H blank actual duration seems to be 87, but will compensate and take extra time depending on how fast the drawing stage took, 
leading to a consistent 456 dot timing for one scanline.

To be exact, the drawing is controlled by this thing called Pixel FIFO.
PPU holds 16 pixels at once to be drawn in a queue.
The ppu draws one pixel per screen per clock, and pauses unless it contains more than 8 pixels.
When fetching more pixels, 3 clocks are needed + 1 idle clock.

============================================

On Interrupts:
3 main parts that control the interrupt system.
IF register 0xFF0F - The state of the interrupts. "Do I need to handle any interrupts?"
IE register 0xFFFF - Interrupt table. Enables/Disables whether each interrupt can be called.
IME flag, internal to cpu - Enables/Disables all interrupts globally.


0xFF41: STAT register for graphics is a weird one.
Bit 7: Unused.
Bit 6: LYC=LY Interrupt Enable (1=enabled)
Bit 5: Mode 2 (OAM Search) Interrupt Enable (1=enabled)
Bit 4: Mode 1 (VBlank) Interrupt Enable (1=enabled)
Bit 3: Mode 0 (HBlank) Interrupt Enable (1=enabled)
Bit 2: LYC=LY Flag (1=LY matches LYC, read-only)
Bit 1-0: PPU Mode (read-only)
  00 = Mode 0 (HBlank)
  01 = Mode 1 (VBlank)
  10 = Mode 2 (OAM Search)
  11 = Mode 3 (Drawing)